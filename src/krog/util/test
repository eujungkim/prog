package com.lgcns.test;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.servlet.ServletHandler;

import com.google.gson.Gson;

public class RunManager {

	public static void main(String[] args) throws Exception {
		new RunManager().start();
	}
	public void start() throws Exception {
		Server server = new Server();
		ServerConnector http = new ServerConnector(server);
		http.setHost("127.0.0.1");
		http.setPort(8080);
		server.addConnector(http);

		ServletHandler servletHandler = new ServletHandler();
		servletHandler.addServletWithMapping(MessageServlet.class, "/CREATE/*");
		servletHandler.addServletWithMapping(MessageServlet.class, "/SEND/*");
		servletHandler.addServletWithMapping(MessageServlet.class, "/RECEIVE/*");
		servletHandler.addServletWithMapping(MessageServlet.class, "/ACK/*");
		servletHandler.addServletWithMapping(MessageServlet.class, "/FAIL/*");
		servletHandler.addServletWithMapping(MessageServlet.class, "/DLQ/*");

		server.setHandler(servletHandler);

		server.start();
		
		new Thread(new TimeOutThread()).start();
		server.join();
	}

}
class Message {
	private String id;
	private String message;
	private boolean lock;
	private int failCount;
	private long receivedTime;
	
	public Message(String message) {
		this.id = UUID.randomUUID().toString();
		this.message = message;
		this.lock = false;
		this.failCount = 0;
		this.receivedTime = -1;
	}

	public long getReceivedTime() {
		return receivedTime;
	}

	public void setReceivedTime(long receivedTime) {
		this.receivedTime = receivedTime;
	}

	public int getFailCount() {
		return failCount;
	}

	public void setFailCount(int failCount) {
		this.failCount = failCount;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	public boolean isLock() {
		return lock;
	}

	public void setLock(boolean lock) {
		this.lock = lock;
	}

	@Override
	public String toString() {
		return "Message [id=" + id + ", message=" + message + ", lock=" + lock + "]";
	}
	
}

class MessageInfo {
	private int queueSize;
	private int processTimeout;
	private int waitTime;
	private int maxFailCount;
	
	public MessageInfo(int queueSize, int processTimeout, int waitTime, int maxFailCount) {
		super();
		this.queueSize = queueSize;
		this.processTimeout = processTimeout;
		this.waitTime = waitTime;
		this.maxFailCount = maxFailCount;
	}
	public int getQueueSize() {
		return queueSize;
	}
	public void setQueueSize(int queueSize) {
		this.queueSize = queueSize;
	}
	public int getProcessTimeout() {
		return processTimeout;
	}
	public void setProcessTimeout(int processTimeout) {
		this.processTimeout = processTimeout;
	}
	public int getWaitTime() {
		return waitTime;
	}
	public void setWaitTime(int waitTime) {
		this.waitTime = waitTime;
	}
	public int getMaxFailCount() {
		return maxFailCount;
	}
	public void setMaxFailCount(int maxFailCount) {
		this.maxFailCount = maxFailCount;
	}
}

class WaitMessage {
	private String id;
	private Message message;
	private long start;
	public WaitMessage(String id, long start) {
		super();
		this.id = id;
		this.start = start;
	}
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public Message getMessage() {
		return message;
	}
	public void setMessage(Message message) {
		this.message = message;
	}
	public long getStart() {
		return start;
	}
	public void setStart(long start) {
		this.start = start;
	}	
}

class MessageService {
	public static Map<String, List<Message>> queueMap = new HashMap<>();
	public static Map<String, List<Message>> deadMap = new HashMap<>();
	public static Map<String, MessageInfo> infoMap = new HashMap<>();
	public static Map<String, List<WaitMessage>> waitMap = new HashMap<>();
	
	public boolean create(String name, MessageInfo info) {
		if (queueMap.containsKey(name)) {
			return false;
		} else {
			queueMap.put(name, Collections.synchronizedList(new LinkedList<Message>()));
			deadMap.put(name, Collections.synchronizedList(new LinkedList<Message>()));
			infoMap.put(name, info);
			waitMap.put(name, Collections.synchronizedList(new LinkedList<WaitMessage>()));
			return true;
		}
	}
	
	public boolean send(String name, String message) {
		if (queueMap.get(name).size() == infoMap.get(name).getQueueSize()) {
			return false;
		} else {
			Message m = new Message(message);
			queueMap.get(name).add(m);
			
			if (MessageService.infoMap.get(name).getWaitTime() > 0) {
				Iterator<WaitMessage> iter = MessageService.waitMap.get(name).iterator();
				while (iter.hasNext()) {
					WaitMessage ws = iter.next();
					if (ws.getMessage() == null) {
						ws.setMessage(m);
						break;
					}
				}				
			}			
			
			return true;
		}
	}
	
	public Message receive(String name) {
		if (queueMap.containsKey(name) && queueMap.get(name).size() > 0) {
			Iterator<Message> iter = queueMap.get(name).iterator();
			while (iter.hasNext()) {
				Message m = iter.next();
				if (!m.isLock()) {
					m.setLock(true);
					m.setReceivedTime(System.currentTimeMillis());
					return m;
				}
			}
		}
		return null;
	}
	
	public void ack(String name, String id) {
		if (queueMap.containsKey(name) && queueMap.get(name).size() > 0) {
			Iterator<Message> iter = queueMap.get(name).iterator();
			while (iter.hasNext()) {
				Message m = iter.next();
				if (id.equals(m.getId())) {
					iter.remove();
					return;
				}
			}
		}
	}
	
	public void fail(String name, String id) {
		if (queueMap.containsKey(name) && queueMap.get(name).size() > 0) {
			Iterator<Message> iter = queueMap.get(name).iterator();
			Message m = null;
			while (iter.hasNext()) {
				m = iter.next();
				if (id.equals(m.getId())) {
					m.setLock(false);
					m.setReceivedTime(-1);
					m.setFailCount(m.getFailCount() + 1);
					break;
				}
			}
			
			if (MessageService.infoMap.get(name).getWaitTime() > 0) {
				Iterator<WaitMessage> iter2 = MessageService.waitMap.get(name).iterator();
				while (iter2.hasNext()) {
					WaitMessage ws = iter2.next();
					if (ws.getMessage() == null) {
						ws.setMessage(m);
						break;
					}
				}				
			}						
			
		}
	}
	
	public synchronized Message dlq(String name) {
		if (deadMap.containsKey(name) && deadMap.get(name).size() > 0) {
			Message result = deadMap.get(name).get(0);
			deadMap.get(name).remove(0);
			return result;
		}
		return null;
	}

}
class MessageServlet extends HttpServlet {

	private static final long serialVersionUID = 1L;
	private static String EXIST = "{\"Result\":\"Queue Exist\"}";
	private static String FULL = "{\"Result\":\"Queue Full\"}";
	private static String NO_MESSAGE = "{\"Result\":\"No Message\"}";
	private static String OK = "{\"Result\":\"Ok\"}";
	private static String MESSAGE = "{\"Result\":\"Ok\",\"MessageId\":\"%s\",\"Message\":\"%s\"}";
	
	private MessageService service = new MessageService();

	protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
		long start = System.currentTimeMillis();
		String[] pathParams = req.getRequestURI().substring(1).split("/");
		if ("RECEIVE".equals(pathParams[0])) {
			String name = pathParams[1];
			Message m = service.receive(name);
			if (m != null) {
				String result = String.format(MESSAGE, m.getId(), m.getMessage());
				res.getWriter().write(result);
			} else {
				if (MessageService.infoMap.get(name).getWaitTime() > 0) {
					String waitId = UUID.randomUUID().toString();
					MessageService.waitMap.get(name).add(new WaitMessage(waitId, start));
					
					while (System.currentTimeMillis() - start < MessageService.infoMap.get(name).getWaitTime() * 1000) {
						try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						
						Iterator<WaitMessage> iter = MessageService.waitMap.get(name).iterator();
						while (iter.hasNext()) {
							WaitMessage ws = iter.next();
							if (ws.getId().equals(waitId) && ws.getMessage() != null) {
								iter.remove();
								m = ws.getMessage();
								String result = String.format(MESSAGE, m.getId(), m.getMessage());
								res.getWriter().write(result);
								res.setStatus(200);
								return;
							}
						}
					}
				}
				res.getWriter().write(NO_MESSAGE);
			}
		} else if ("DLQ".equals(pathParams[0])) {
			String name = pathParams[1];
			Message m = service.dlq(name);
			if (m != null) {
				String result = String.format(MESSAGE, m.getId(), m.getMessage());
				res.getWriter().write(result);
			} else {
				res.getWriter().write(NO_MESSAGE);
			}
		}
		res.setStatus(200);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
	    // {"QueueSize":15,"ProcessTimeout":2,"WaitTime":5,"MaxFailCount":1}
		String[] pathParams = req.getRequestURI().substring(1).split("/");
		if ("CREATE".equals(pathParams[0])) {
			String name = pathParams[1];
			Map<String, Object> map = new HashMap<String, Object>();
			map = new Gson().fromJson(getReqBody(req), map.getClass());
			int size = ((Double)map.get("QueueSize")).intValue();
			MessageInfo info = new MessageInfo(((Double)map.get("QueueSize")).intValue(),
					((Double)map.get("ProcessTimeout")).intValue(), 
					((Double)map.get("WaitTime")).intValue(), 
					((Double)map.get("MaxFailCount")).intValue());
			if (service.create(name, info)) {
				res.getWriter().write(OK);
			} else {
				res.getWriter().write(EXIST);
			}
		} else if ("SEND".equals(pathParams[0])) {
			String name = pathParams[1];
			Map<String, Object> map = new HashMap<String, Object>();
			map = new Gson().fromJson(getReqBody(req), map.getClass());
			String message = (String)map.get("Message");
			if (service.send(name, message)) {
				res.getWriter().write(OK);
			} else {
				res.getWriter().write(FULL);
			}
		} else if ("ACK".equals(pathParams[0])) {
			String name = pathParams[1];
			String id = pathParams[2];
			service.ack(name, id);
			res.getWriter().write(OK);
		} else if ("FAIL".equals(pathParams[0])) {
			String name = pathParams[1];
			String id = pathParams[2];
			service.fail(name, id);
			res.getWriter().write(OK);
		}
		res.setStatus(200);
	}
	
	public String getReqBody(HttpServletRequest req) throws IOException {
		return req.getReader().lines().collect(Collectors.joining(System.lineSeparator()));
	}

}

class TimeOutThread implements Runnable {

	@Override
	public void run() {

		while (true) {
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			for (String name : MessageService.queueMap.keySet()) {
				List<Message> queue = MessageService.queueMap.get(name);
				MessageInfo info = MessageService.infoMap.get(name);
				if (info.getProcessTimeout() > 0) {
					Iterator<Message> iter = queue.iterator();
					while (iter.hasNext()) {
						Message m = iter.next();
						if (m.getFailCount() > info.getMaxFailCount()) {
							MessageService.deadMap.get(name).add(m);
							iter.remove();
							continue;
						}
						
						if (m.getReceivedTime() != -1 && 
								System.currentTimeMillis() - m.getReceivedTime() > info.getProcessTimeout() * 1000) {
							m.setLock(false);
							m.setReceivedTime(-1);
							m.setFailCount(m.getFailCount() + 1);
						}
					}
				}
			}
		}
	}

}
